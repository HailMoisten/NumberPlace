<!DOCTYPE html>
<html lang="jp">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-14717K4QJ1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-14717K4QJ1');
  </script>
  <meta charset="UTF-8">
  <title>Number Place</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="favicon.ico">
  <style>
    /* ---------------------------------------------------
       ルートのカスタムプロパティ
       ・太い枠色用変数 (--grid-border-color)
       ・選択セル強調用の薄色 (--highlight-color-note, --highlight-color-answer)
    --------------------------------------------------- */
    :root {
      --font-size-S: 9px;
      --font-size-M: 20px;
      --font-size-L: 30px;
      --color-text: #333;
      --color-text-highlight: white;
      --color-button: #555;
      --color-button-hover: #444;
      --color-cand1: #d4edda;
      --color-cand2: #fff3cd;
      --color-cand3: #f8d7da;
      --color-plus: #438445;
      --color-minus: #FF6600;
      --color-difficulty1: #306061;
      --color-difficulty2: #30613b;
      --color-difficulty3: #74663a;
      --color-difficulty4: #613030;
      --color-difficulty5: #60306b;
      --color-difficulty6: #391921;
      --color-difficulty7: black;
      --color-selected-answer: #ff9100;
      --color-selected-memo: #30613b;
      --grid-border-color: var(--color-difficulty3); /* 初期は回答モード */
      --highlight-color-note: rgba(191, 255, 205, 0.2);
      --highlight-color-answer: rgba(253, 238, 191, 0.2);
    }
    /* タブレット */
    @media screen and (max-width:350px) {
      :root {
        --font-size-S: 7px;
        --font-size-M: 12px;
        --font-size-L: 18px;
      }
    }
    /* タブレット */
    @media screen and (min-width:500px) {
      :root {
        --font-size-S: 11px;
        --font-size-M: 24px;
        --font-size-L: 42px;
      }
    }

    /* ---------------------------------------------------
       基本レイアウト・フォント・レスポンシブ調整
    --------------------------------------------------- */
    body {
      font-family: 'Gill Sans', 'Gill Sans MT', Helvetica, 'Noto Sans JP', Arial, sans-serif;
      background-color: #f7f7f7;
      margin: 0;
      padding: 0;
      text-align: center;
      position: relative;
      touch-action: manipulation;
    }
    /* 各画面の共通コンテナ */
    #startScreen, #gameScreen, #resultScreen {
      padding: 20px;
      max-width: 500px;
      margin: auto;
      display: flex;
      justify-content: center;
      flex-direction: column;
      align-items: center;
      animation: fadeIn 1.0s ease-out;
    }
    h1, h2 {
      margin: 10px;
      font-size: var(--font-size-L);
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* ---------------------------------------------------
       iOS風トグルボタン（デイリーボード用）
    --------------------------------------------------- */
    .switch {
      position: relative;
      display: inline-block;
      width: 54px;
      height: 30px;
      vertical-align: middle;
      margin: 5px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 24px;
      width: 24px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: var(--color-difficulty3);
    }
    input:checked + .slider:before {
      transform: translateX(24px);
    }

    /* ---------------------------------------------------
       ボタン
    --------------------------------------------------- */
    button {
      font-family: inherit;
      margin: 5px;
      padding: 8px 12px;
      font-size: var(--font-size-M);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s;
      background-color: var(--color-button);
      color: var(--color-text-highlight);
    }
    button:hover {
      background-color: var(--color-button-hover);
      transform: scale(1.05);
    }
    
    /* ---------------------------------------------------
       上部ステータスライン：難易度とタイマー
    --------------------------------------------------- */
    #statusLine {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      max-height: 50px;
      font-size: var(--font-size-M);
      margin-bottom: 10px;
    }
    #difficultyDisplay { font-weight: bold; }
    
    /* ---------------------------------------------------
       np Grid（9×9 テーブル）
         ※幅を統一するため width:100% と max-width:450px を指定
    --------------------------------------------------- */
    #npGrid {
      border-collapse: collapse;
      margin: 0 auto 10px;
      table-layout: fixed;
      width: 90%;
      height: 90vmin;
      aspect-ratio: 1;
      max-width: 450px;
      max-height: 450px;
      color: var(--color-text);
    }
    #npGrid td {
      position: relative; /* ハイライト用疑似要素のため */
      aspect-ratio: 1;
      font-size: var(--font-size-L);
      width: 7vmin;
      height: 7vmin;
      max-width: 50px;
      max-height: 50px;
      border: 1px solid #999;
      vertical-align: middle;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    /* 3×3 ブロックごとの太い枠：色はCSS変数で動的に変更 */
    #npGrid tr:nth-child(3n+1) td { border-top: 3px solid var(--grid-border-color); }
    #npGrid tr td:nth-child(3n+1) { border-left: 3px solid var(--grid-border-color); }
    #npGrid tr:last-child td { border-bottom: 3px solid var(--grid-border-color); }
    #npGrid tr td:last-child { border-right: 3px solid var(--grid-border-color); }

    /* ハイライト用：highlighted クラスを持つセルは ::before で上から半透明オーバーレイ */
    #npGrid td.highlighted::before {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: var(--cell-highlight-color);
      pointer-events: none;
      z-index: 2;
    }

    /* ---------------------------------------------------
       セル内コンテンツ：メイン数字 & メモ
         ※.main-value はセル全体を埋める
    --------------------------------------------------- */
    .cell-content {
      width: 100%;
      height: 100%;
      position: relative;
    }
    .main-value {
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: var(--font-size-L);
      width: 100%;
      height: 100%;
    }
    .notes {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      pointer-events: none;
      font-size: var(--font-size-S);
      color: #999;
    }
    .notes .note {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    /* 与えられたセル */
    td.given .main-value {
      background-color: #eaeaea;
    }
    /* ユーザー入力済みセル */
    td.answered .main-value {
      background-color: #fff;
    }
    /* 選択中セル（outlineは updateHighlights() で設定） */
    td.selected {
      z-index: 1;
    }
    /* 正解時のフラッシュ */
    td.correct { animation: correctFlash 0.5s; }
    @keyframes correctFlash {
      from { background-color: var(--color-plus); }
      to { background-color: transparent; }
    }
    /* 不正解時のフラッシュ */
    td.wrong { animation: wrongFlash 0.5s; }
    @keyframes wrongFlash {
      from { background-color: var(--color-minus); }
      to { background-color: transparent; }
    }
    /* ---------------------------------------------------
       候補ハイライト色
    --------------------------------------------------- */
    td.cand1 { background-color: var(--color-cand1) !important; }
    td.cand2 { background-color: var(--color-cand2) !important; }
    td.cand3 { background-color: var(--color-cand3) !important; }
    
    /* ---------------------------------------------------
       Number Buttons（npGrid と同じ幅になるよう width:100% / max-width:450px）
    --------------------------------------------------- */
    #numberButtons {
      aspect-ratio: 9 / 1;
      display: grid;
      width: 90vmin;
      height: 9vmin;
      max-width: 486px;
      max-height: 50px;
      font-size: var(--font-size-L);
      grid-template-columns: repeat(9, 11%);
      justify-content: center;
      margin: 0 auto 10px;
    }
    
    /* ---------------------------------------------------
       Stats Panel（ポイント、正解数、ミス、コンボ）
    --------------------------------------------------- */
    #statsPanel {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      font-size: var(--font-size-M);
      margin-bottom: 10px;
      color: var(--color-text);
    }
    
    /* ---------------------------------------------------
       Controls Panel（候補ハイライト、モード切替、ギブアップ）
    --------------------------------------------------- */
    #controls {
      display: flex;
      justify-content: space-around;
      align-items: center;
      max-height: 45px;
      gap: 10px;
      font-size: var(--font-size-S);
    }
    
    /* ---------------------------------------------------
       アニメーション定義
    --------------------------------------------------- */
    .animate-combo {
      animation: comboPulse 0.5s ease;
    }
    @keyframes comboPulse {
      0% { transform: scale(1); }
      15% { transform: scale(1.3); }
      100% { transform: scale(1); }
      from { color: var(--color-plus); }
      to { color: var(--color-text); }
    }
    .animate-mistake {
      animation: mistakePulse 0.5s ease;
    }
    @keyframes mistakePulse {
      0% { transform: scale(1); }
      15% { transform: scale(1.3); }
      100% { transform: scale(1); }
      from { color: var(--color-minus); }
      to { color: var(--color-text); }
    }
    .animate-correct {
      animation: correctPulse 0.5s ease;
    }
    @keyframes correctPulse {
      0% { transform: scale(1); }
      15% { transform: scale(1.3); }
      100% { transform: scale(1); }
      from { color: var(--color-plus); }
      to { color: var(--color-text); }
    }
    .animate-points { animation: pointsPulse 0.5s ease; }
    @keyframes pointsPulse {
      0% { transform: scale(1); }
      15% { transform: scale(1.3); }
      100% { transform: scale(1); }
      from { color: var(--color-plus); }
      to { color: var(--color-text); }
    }
    .animate-button {
      animation: buttonPulse 1.0s ease;
    }
    @keyframes buttonPulse {
      0% { transform: scale(1); }
      15% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }
    .animate-button-plus {
      animation: buttonPlusPulse 1.0s ease;
    }
    @keyframes buttonPlusPulse {
      0% { transform: scale(1); }
      15% { transform: scale(1.3); }
      100% { transform: scale(1); }
      from { background-color: var(--color-plus); }
      to { background-color: var(--color-button); }
    }
    .animate-button-minus {
      animation: buttonMinusPulse 1.0s ease;
    }
    @keyframes buttonMinusPulse {
      0% { transform: scale(1); }
      15% { transform: scale(1.3); }
      100% { transform: scale(1); }
      from { background-color: var(--color-minus); }
      to { background-color: var(--color-button); }
    }
    
    /* ---------------------------------------------------
       Result Overlay（ゲーム画面上に半透明オーバーレイ）
    --------------------------------------------------- */
    #resultScreen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 10;
      display: none;
      justify-content: center;
      align-items: center;
      padding: 20px;
      color:#333;
    }
    /* Result Card */
    #resultCard {      
      background: rgba(255, 255, 255, 0.8);
      padding: 10px 10px;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      text-align: center;
      font-size: var(--font-size-M);
      color: #333;
      max-width: 90%;
      margin: 0 auto;
    }
    #resultDifficulty { 
      font-size: 1.2em;
      font-weight: bold; 
      margin-right: 10px; 
    }
    #resultScore { 
      font-size: 1.5em;
      font-weight: bold; 
      margin-left: 10px; 
      margin-right: 20px; 
    }
    /* Result stats 一行 */
    #resultStats {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      font-size: var(--font-size-M);
      margin-bottom: 10px;
    }
    /* Signature Area */
    #signatureArea {
      background: rgba(255, 255, 255, 0.3);
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      width: 95%;
      max-width: 100%-10px;
    }
    #signatureArea h3 {
      margin: 0 0 5px 0;
      font-size: var(--font-size-M);
      text-align: left;
    }
  </style>
</head>
<body>
  <!-- Start Screen: 難易度選択＋デイリーボードトグル -->
  <div id="startScreen">
    <h1>Number Place</h1>
    <p style="font-size: var(--font-size-M);">SELECT DIFFICULTY</p>
    <!-- 各難易度ボタン -->
    <button id="superEasyBtn" style="background-color: var(--color-difficulty1);">SUPER EASY 10 (1)</button>
    <button id="easyBtn" style="background-color: var(--color-difficulty2);">EASY 20 (2)</button>
    <button id="mediumBtn" style="background-color: var(--color-difficulty3);">MEDIUM 30 (3)</button>
    <button id="hardBtn" style="background-color: var(--color-difficulty4);">HARD 40 (4)</button>
    <button id="ultraHardBtn" style="background-color: var(--color-difficulty5);">ULTRA HARD 50 (5)</button>
    <button id="extremeHardBtn" style="background-color: var(--color-difficulty6);">EXTREME HARD 55 (6)</button>
    <button id="supremeHardBtn" style="background-color: var(--color-difficulty7);">SUPREME HARD 60 (7)</button>
    <!-- デイリーボードトグル（iOS風） -->
    <div id="dailyBoardToggleContainer" style="margin: 10px;">
      <label class="switch">
        <input type="checkbox" id="dailyBoardToggle">
        <span class="slider round"></span>
      </label>
      <span id="dailyBoardLabel" style="font-size: var(--font-size-M); vertical-align: middle;" >DAILY BOARD</span>
      <span id="todayDate" style="font-size: var(--font-size-M); vertical-align: middle;" ></span>
    </div>
    <script>
      document.getElementById('todayDate').textContent =
        " of " + new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' });
    </script>
    <aside>ver.2025.2.24 <a href="https://github.com/HailMoisten/NumberPlace" target="_blank">GitHub</a><br>GPL-3.0 license © 2025 Hail Moisten</aside>
  </div>

  <!-- Game Screen -->
  <div id="gameScreen" style="display:none;">
    <!-- ステータスライン -->
    <div id="statusLine">
      <span id="difficultyDisplay"></span>
      <span id="timeDisplay">00:00</span>
    </div>
    <!-- npGrid -->
    <table id="npGrid"></table>
    <!-- Number Buttons -->
    <div id="numberButtons"></div>
    <!-- Stats Panel -->
    <div id="statsPanel">
      <span id="pointsDisplay">1 pt</span>
      <span id="correctsDisplay">○ 0</span>
      <span id="mistakesDisplay">× 0</span>
      <span id="comboDisplay">0 combo</span>
    </div>
    <!-- Controls Panel -->
    <div id="controls">
      <button id="highlightBtn" style="font-size: 1.0em;">Candidates(c)<br>1 pt</button>
      <button id="modeToggleBtn" style="font-size: 1.0em;"><b>Answer(a)</b><br>/Memo(m)</button>
      <button id="magickeyBtn" style="font-size: 1.0em;">Magickey(k)<br>50 pt</button>
      <button id="giveUpBtn" style="font-size: 1.0em;">Forfeit<br>(Esc)</button>
    </div>
  </div>
  
  <!-- Result Overlay -->
  <div id="resultScreen" style="display:none;">
    <div id="resultCard">
      <span id="resultDifficulty"></span>
      <strong>Score </strong><span id="resultScore"></span>
      <!-- Result Stats -->
      <div id="resultStats">
        <span id="resultTime"></span>
        <span id="resultPoints"></span>
        <span id="resultCorrects"></span>
        <span id="resultMistakes"></span>
        <span id="resultCombo"></span>
      </div>
      <!-- Signature Area -->
      <div id="signatureArea">
        <h3>Signature</h3>
        <canvas id="signatureCanvas" width="450" height="150"></canvas>
      </div>
      <button id="restartBtn" style="font-size: var(--font-size-M)">Exit (Esc)</button>
    </div>
  </div>
  
  <script>
    /********************************************
     * グローバル変数・難易度設定
    ********************************************/
    let board = [];           // 9x9盤面
    let solution = [];        // 完全解
    let givenPuzzle = [];     // 与えられた盤面
    let selectedCell = null;  // 選択中セル（td 要素）
    let timerInterval = null; // タイマー
    let startTime;            // 開始時刻
    let mistakeCount = 0;     
    let correctCount = 0;     
    let comboCount = 0;       
    let currentDifficulty = 'easy';
    let candidateHighlightLevel = 0;  // 0～3
    let isNoteMode = false;   // false: 回答モード, true: メモモード
    let points = 1;           
    let difficultyColor = "#000"; 
    let diffText = "";
    
    const difficultySettings = {
      superEasy: { cells: 10, label: "SUPER EASY 10" },
      easy: { cells: 20, label: "EASY 20" },
      medium: { cells: 30, label: "MEDIUM 30" },
      hard: { cells: 40, label: "HARD 40" },
      ultraHard: { cells: 50, label: "ULTRA HARD 50" },
      extremeHard: { cells: 55, label: "EXTREME HARD 55" },
      supremeHard: { cells: 60, label: "SUPREME HARD 60" }
    };

    /********************************************
     * スタート画面の難易度選択ボタン（リファクタリング済み）
    ********************************************/
    const difficultyButtons = [
      { id: 'superEasyBtn', difficulty: 'superEasy' },
      { id: 'easyBtn', difficulty: 'easy' },
      { id: 'mediumBtn', difficulty: 'medium' },
      { id: 'hardBtn', difficulty: 'hard' },
      { id: 'ultraHardBtn', difficulty: 'ultraHard' },
      { id: 'extremeHardBtn', difficulty: 'extremeHard' },
      { id: 'supremeHardBtn', difficulty: 'supremeHard' }
    ];
    difficultyButtons.forEach(btn => {
      document.getElementById(btn.id).addEventListener('click', function(){
        difficultyColor = this.style.backgroundColor;
        document.getElementById('startScreen').style.display = "none";
        document.getElementById('gameScreen').style.display = "block";
        initGame(btn.difficulty);
      });
    });
    
    /********************************************
     * 配列のディープコピー
    ********************************************/
    function deepCopy(arr) {
      return arr.map(row => row.slice());
    }
    
    /********************************************
     * 完全盤面の生成（バックトラック・シード対応）
     * randomFn: 乱数関数（通常はMath.random、デイリーボードの場合はseed付き）
    ********************************************/
    function generateCompleteBoard(randomFn) {
      let board = Array.from({ length: 9 }, () => Array(9).fill(0));
      function isValid(board, r, c, num) {
        for (let i = 0; i < 9; i++) {
          if (board[r][i] === num || board[i][c] === num) return false;
        }
        const boxRow = Math.floor(r / 3) * 3;
        const boxCol = Math.floor(c / 3) * 3;
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (board[boxRow + i][boxCol + j] === num) return false;
          }
        }
        return true;
      }
      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(randomFn() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }
      function solve(cell = 0) {
        if (cell === 81) return true;
        const r = Math.floor(cell / 9);
        const c = cell % 9;
        if (board[r][c] !== 0) return solve(cell + 1);
        let nums = shuffle([1,2,3,4,5,6,7,8,9]);
        for (let num of nums) {
          if (isValid(board, r, c, num)) {
            board[r][c] = num;
            if (solve(cell + 1)) return true;
            board[r][c] = 0;
          }
        }
        return false;
      }
      solve();
      return board;
    }
    
    /********************************************
     * シード付き乱数生成器（Linear Congruential Generator）
    ********************************************/
    function seededRandom(seed) {
      let m = 0x80000000; // 2^31
      let a = 1103515245;
      let c = 12345;
      let state = seed;
      return function() {
         state = (a * state + c) % m;
         return state / (m - 1);
      }
    }
    
    /********************************************
     * 与えられた盤面の作成（難易度に応じてセル除去＋強制候補ルール）
    ********************************************/
    function createPuzzle(fullBoard, difficulty) {
      let puzzle = deepCopy(fullBoard);
      let cellsToRemove = difficultySettings[difficulty].cells;
      points += Math.round(cellsToRemove/10);
      let removalAttempts = 0;
      const threshold = 100;
      while (cellsToRemove > 0) {
        const r = Math.floor(Math.random() * 9);
        const c = Math.floor(Math.random() * 9);
        if (removalAttempts > threshold) {
          if (puzzle[r][c] !== 0) {
            puzzle[r][c] = 0;
            cellsToRemove--;
            removalAttempts = 0;
          }
        }
        else {
          removalAttempts++;
          let candBefore = 0;
          let candAfter = 0;
          if (puzzle[r][c] !== 0) {
            const backup = puzzle[r][c];
            for (let i = 0; i < 9; i++) {
              for (let j = 0; j < 9; j++) {
                if (puzzle[i][j] === 0) {
                  const cand = getCandidatesForPuzzle(puzzle, i, j);
                  if (cand.length === 1) { candBefore++; }
                }
              }
            }
            puzzle[r][c] = 0;
            for (let i = 0; i < 9; i++) {
              for (let j = 0; j < 9; j++) {
                if (puzzle[i][j] === 0) {
                  const cand = getCandidatesForPuzzle(puzzle, i, j);
                  if (cand.length === 1) { candAfter++; }
                }
              }
            }
            if (candBefore - candAfter <= 2 && candBefore - candAfter > 0) {
              cellsToRemove--;
            } else {
              puzzle[r][c] = backup;
            }
          }
        }
      }
      return puzzle;
    }
    
    // 与えられた盤面 puz に対してセル[r][c]の候補リストを返す
    function getCandidatesForPuzzle(puz, r, c) {
      let candidates = [];
      if (puz[r][c] !== 0) return candidates;
      for (let num = 1; num <= 9; num++) {
        if (isValidForCell(puz, r, c, num)) {
          candidates.push(num);
        }
      }
      return candidates;
    }
    
    /********************************************
     * 盤面（npGrid）のレンダリング
    ********************************************/
    function renderGrid() {
      const grid = document.getElementById('npGrid');
      grid.innerHTML = '';
      for (let r = 0; r < 9; r++) {
        const rowElem = document.createElement('tr');
        for (let c = 0; c < 9; c++) {
          const cell = document.createElement('td');
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.noteSet = new Set();
          const cellContent = document.createElement('div');
          cellContent.classList.add('cell-content');
          const mainValue = document.createElement('div');
          mainValue.classList.add('main-value');
          if (givenPuzzle[r][c] !== 0) {
            mainValue.textContent = givenPuzzle[r][c];
          }
          const notesDiv = document.createElement('div');
          notesDiv.classList.add('notes');
          cellContent.appendChild(mainValue);
          cellContent.appendChild(notesDiv);
          cell.appendChild(cellContent);
          if (givenPuzzle[r][c] !== 0) {
            cell.classList.add('given');
          }
          cell.addEventListener('click', onCellClick);
          rowElem.appendChild(cell);
        }
        grid.appendChild(rowElem);
      }
      // 初期選択（中央付近：4,4）
      let initCell = document.querySelector('#npGrid td[data-row="4"][data-col="4"]');
      if (initCell) {
        selectedCell = initCell;
        selectedCell.classList.add('selected');
      }
      updateHighlights();
    }
    
    /********************************************
     * Number Buttons のレンダリング（1～9）
    ********************************************/
    function renderNumberButtons() {
      const container = document.getElementById('numberButtons');
      container.innerHTML = '';
      for (let i = 1; i <= 9; i++) {
        const btn = document.createElement('button');
        btn.style.fontSize = "var(--font-size-L)";
        btn.style.margin = "2px";
        btn.style.width = "9vmin";
        btn.style.height = "9vmin";
        btn.style.maxWidth = "48px";
        btn.style.maxHeight = "48px";
        btn.style.padding = "0px";
        btn.textContent = i;
        btn.dataset.number = i;
        btn.addEventListener('click', () => onNumberInput(parseInt(btn.dataset.number)));
        container.appendChild(btn);
      }
    }

    /********************************************
     * セルクリックハンドラ
    ********************************************/
    function onCellClick(e) {
      if (selectedCell) {
        // 前回選択セルの outline をクリア
        selectedCell.style.outline = '';
        selectedCell.classList.remove('selected');
      }
      selectedCell = e.currentTarget;
      selectedCell.classList.add('selected');
      updateHighlights();
    }
    
    /********************************************
     * 数字入力ハンドラ
    ********************************************/
    function onNumberInput(num) {
      if (!selectedCell) return;
      const r = parseInt(selectedCell.dataset.row);
      const c = parseInt(selectedCell.dataset.col);
      if (board[r][c] !== 0) return;
      const mainValueElem = selectedCell.querySelector('.main-value');
      const notesElem = selectedCell.querySelector('.notes');
      
      if (isNoteMode) {
        if (selectedCell.noteSet.has(num)) {
          selectedCell.noteSet.delete(num);
        } else {
          selectedCell.noteSet.add(num);
        }
        updateCellNotes(selectedCell);
      } else {
        if (solution[r][c] === num) {
          let bonus = getCandidates(r, c).length;
          board[r][c] = num;
          mainValueElem.textContent = num;
          selectedCell.classList.add('correct', 'answered');
          comboCount++;
          points += bonus * comboCount;
          showPointBonus(bonus * comboCount);
          correctCount++;
          const correctsDisplay = document.getElementById('correctsDisplay');
          correctsDisplay.classList.add('animate-correct');
          setTimeout(() => correctsDisplay.classList.remove('animate-correct'), 500);
          const comboDisplay = document.getElementById('comboDisplay');
          comboDisplay.classList.add('animate-correct');
          setTimeout(() => comboDisplay.classList.remove('animate-correct'), 500);
          clearCandidateHighlights();
          candidateHighlightLevel = 0;
          document.getElementById('highlightBtn').innerHTML = 'Candidates(c)<br>1 pt';
          selectedCell.noteSet.clear();
          notesElem.innerHTML = '';
          updateStats();
          if (isBoardComplete()) {
            clearInterval(timerInterval);
            showResult();
          }
        } else {
          mistakeCount++;
          comboCount = 0;
          const mistakesDisplay = document.getElementById('mistakesDisplay');
          mistakesDisplay.classList.add('animate-mistake');
          setTimeout(() => mistakesDisplay.classList.remove('animate-mistake'), 500);
          updateStats();
          selectedCell.classList.add('wrong');
          const candidates = getCandidates(r, c);
          updateCellNotesWithCandidates(selectedCell, candidates);
          setTimeout(() => selectedCell.classList.remove('wrong'), 500);
        }
      }
    }
    
    /********************************************
     * セルのメモ更新（Memo モード）
    ********************************************/
    function updateCellNotes(cell) {
      const notesElem = cell.querySelector('.notes');
      notesElem.innerHTML = '';
      const notesArray = Array.from(cell.noteSet).sort((a, b) => a - b);
      notesArray.forEach(n => {
        const noteDiv = document.createElement('div');
        noteDiv.classList.add('note');
        noteDiv.style.gridColumnStart = ((n - 1) % 3) + 1;
        noteDiv.style.gridRowStart = Math.floor((n - 1) / 3) + 1;
        noteDiv.textContent = n;
        notesElem.appendChild(noteDiv);
      });
    }
    
    /********************************************
     * 間違い時の候補表示更新
    ********************************************/
    function updateCellNotesWithCandidates(cell, candidates) {
      const notesElem = cell.querySelector('.notes');
      notesElem.innerHTML = '';
      candidates.forEach(n => {
        const noteDiv = document.createElement('div');
        noteDiv.classList.add('note');
        noteDiv.style.gridColumnStart = ((n - 1) % 3) + 1;
        noteDiv.style.gridRowStart = Math.floor((n - 1) / 3) + 1;
        noteDiv.textContent = n;
        notesElem.appendChild(noteDiv);
      });
    }
    
    /********************************************
     * 全セルの候補ハイライト解除
    ********************************************/
    function clearCandidateHighlights() {
      document.querySelectorAll('#npGrid td').forEach(cell => {
        cell.classList.remove('cand1','cand2','cand3');
      });
    }
    
    /********************************************
     * 候補ハイライト更新（候補数が閾値以下の場合）
    ********************************************/
    function updateCandidateHighlights() {
      document.querySelectorAll('#npGrid td').forEach(cell => {
        const r = parseInt(cell.dataset.row);
        const c = parseInt(cell.dataset.col);
        if (board[r][c] !== 0) {
          cell.classList.remove('cand1','cand2','cand3');
          return;
        }
        const candidates = getCandidates(r, c);
        cell.classList.remove('cand1','cand2','cand3');
        if (candidates.length > 0 && candidates.length <= candidateHighlightLevel) {
          cell.classList.add('cand' + candidates.length);
        }
      });
      if (candidateHighlightLevel >= 3) {
        document.getElementById('highlightBtn').innerHTML = 'Candidates(c)<br>-' + ' pt';
      } else {
        document.getElementById('highlightBtn').innerHTML = 'Candidates(c)<br><b>' + (candidateHighlightLevel+1) + ' pt</b>';
      }
    }
    
    /********************************************
     * 指定セルに num を置くことが可能か判定
    ********************************************/
    function isValidForCell(board, r, c, num) {
      for (let i = 0; i < 9; i++) {
        if (board[r][i] === num || board[i][c] === num) return false;
      }
      const boxRow = Math.floor(r / 3) * 3;
      const boxCol = Math.floor(c / 3) * 3;
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          if (board[boxRow + i][boxCol + j] === num) return false;
        }
      }
      return true;
    }
    
    /********************************************
     * セル [r][c] の有効候補を取得
    ********************************************/
    function getCandidates(r, c) {
      let candidates = [];
      if (board[r][c] !== 0) return candidates;
      for (let num = 1; num <= 9; num++) {
        if (isValidForCell(board, r, c, num)) {
          candidates.push(num);
        }
      }
      return candidates;
    }
    
    /********************************************
     * タイマー更新（mm:ss 表示）
    ********************************************/
    function updateTimer() {
      const now = new Date();
      const elapsed = Math.floor((now - startTime) / 1000);
      const m = String(Math.floor(elapsed / 60)).padStart(2, '0');
      const s = String(elapsed % 60).padStart(2, '0');
      document.getElementById('timeDisplay').textContent = m + ':' + s;
    }
    
    /********************************************
     * タイマー開始
    ********************************************/
    function startTimer() {
      startTime = new Date();
      timerInterval = setInterval(updateTimer, 1000);
    }
    
    /********************************************
     * 盤面が全て埋まっているか判定
    ********************************************/
    function isBoardComplete() {
      for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
          if (board[r][c] === 0) return false;
        }
      }
      return true;
    }
    
    /********************************************
     * Stats Panel 更新（ポイント、正解数、ミス、コンボ）
    ********************************************/
    function updateStats() {
      document.getElementById('pointsDisplay').textContent = points + " pt";
      document.getElementById('mistakesDisplay').textContent = "× " + mistakeCount;
      document.getElementById('correctsDisplay').textContent = "○ " + correctCount;
      document.getElementById('comboDisplay').textContent = comboCount + " combo";
    }
    
    /********************************************
     * ポイントボーナスのアニメーション表示（pointsDisplay 上部）
    ********************************************/
    function showPointBonus(bonus) {
      if (bonus <= 0) return;
      const bonusElem = document.createElement('span');
      bonusElem.textContent = " + " + bonus + " pt";
      bonusElem.style.color = "var(--color-plus)";
      bonusElem.style.fontSize = "18px";
      bonusElem.style.fontWeight = "bold";
      bonusElem.style.position = "absolute";
      const pointsDisplay = document.getElementById('pointsDisplay');
      pointsDisplay.classList.add('animate-points');
      setTimeout(() => pointsDisplay.classList.remove('animate-points'), 1000);
      const rect = pointsDisplay.getBoundingClientRect();
      bonusElem.style.left = (rect.left + rect.width/2) + "px";
      bonusElem.style.top = (rect.top + 4) + "px";
      bonusElem.style.transform = "translate(-50%, -110%)";
      document.body.appendChild(bonusElem);
      bonusElem.style.transition = "opacity 1.5s ease, transform 1.5s ease";
      setTimeout(() => {
        bonusElem.style.opacity = "0";
        bonusElem.style.transform = "translate(-50%, -150%)";
      }, 100);
      setTimeout(() => { document.body.removeChild(bonusElem); }, 1600);
      updateStats();
    }
    
    /********************************************
     * 選択セルの行・列・3×3ブロックをハイライト
     * → npGrid内の各セルに、highlighted クラスを付与し、
     *    各セルに --cell-highlight-color を設定して疑似要素で上から表示する。
     *    また、全セルの outline をリセットしてから、選択セルにのみ outline を設定する。
    ********************************************/
    function updateHighlights() {
      // すべてのセルの背景色・outline・ハイライト用クラス・変数をリセット
      document.querySelectorAll('#npGrid td').forEach(cell => {
        cell.style.outline = '';
        cell.classList.remove('highlighted');
        cell.style.removeProperty('--cell-highlight-color');
      });
      if (!selectedCell) return;
      const selRow = parseInt(selectedCell.dataset.row);
      const selCol = parseInt(selectedCell.dataset.col);
      const highlightColor = isNoteMode 
            ? getComputedStyle(document.documentElement).getPropertyValue('--highlight-color-note')
            : getComputedStyle(document.documentElement).getPropertyValue('--highlight-color-answer');
      
      // 同じ行、列、またはブロックのセルにハイライトクラスと変数を設定
      document.querySelectorAll('#npGrid td').forEach(cell => {
        let r = parseInt(cell.dataset.row);
        let c = parseInt(cell.dataset.col);
        if (cell === selectedCell) return;
        if (r === selRow || c === selCol || (Math.floor(r/3) === Math.floor(selRow/3) && Math.floor(c/3) === Math.floor(selCol/3))) {
          cell.classList.add('highlighted');
          cell.style.setProperty('--cell-highlight-color', highlightColor, 'important');
        }
      });
      // 選択セルの outline を isNoteMode に応じて設定
      if (isNoteMode) {
        selectedCell.style.outline = "2px solid var(--color-selected-memo)";
      } else {
        selectedCell.style.outline = "2px solid var(--color-selected-answer)";
      }
    }
    
    /********************************************
     * ゲーム初期化：盤面生成、各カウントリセット、レンダリング開始
     * デイリーボードがオンの場合、今日の日付からシードを作成して同じsolutionに
    ********************************************/
    function initGame(difficulty) {
      currentDifficulty = difficulty;
      const dailyBoardOn = document.getElementById('dailyBoardToggle').checked;
      let randomFn = Math.random;
      if (dailyBoardOn) {
        const today = new Date();
        const seed = today.getFullYear() * 10000 + (today.getMonth()+1) * 100 + today.getDate();
        randomFn = seededRandom(seed);
      }
      solution = generateCompleteBoard(randomFn);
      points = 0;
      mistakeCount = 0;
      correctCount = 0;
      comboCount = 0;
      givenPuzzle = createPuzzle(solution, difficulty);
      board = deepCopy(givenPuzzle);
      candidateHighlightLevel = 0;
      updateStats();
      diffText = difficultySettings[difficulty].label;
      var displayDiff = dailyBoardOn ? diffText + " (DAILY)" : diffText;
      document.getElementById('difficultyDisplay').innerHTML =
        "<span style='color:" + difficultyColor + "'>" + displayDiff + "</span>";
      document.getElementById('highlightBtn').innerHTML = 'Candidates(c)<br>1 pt';
      renderGrid();
      renderNumberButtons();
      clearCandidateHighlights();
      isNoteMode = false;
      updateModeButton();
      startTimer();
    }    
    
    /********************************************
     * キーボード入力ハンドリング
    ********************************************/
    document.addEventListener('keydown', (e) => {
      if (document.getElementById('startScreen').style.display !== "none") {
        if (e.key === "1") { document.getElementById('superEasyBtn').click(); return; }
        if (e.key === "2") { document.getElementById('easyBtn').click(); return; }
        if (e.key === "3") { document.getElementById('mediumBtn').click(); return; }
        if (e.key === "4") { document.getElementById('hardBtn').click(); return; }
        if (e.key === "5") { document.getElementById('ultraHardBtn').click(); return; }
        if (e.key === "6") { document.getElementById('extremeHardBtn').click(); return; }
        if (e.key === "7") { document.getElementById('supremeHardBtn').click(); return; }
      }
      if (document.getElementById('resultScreen').style.display !== "none") {
        if (e.key === "Escape") { document.getElementById('restartBtn').click(); return; }
      }
      if (document.getElementById('gameScreen').style.display !== "none") {
        if (e.key.toLowerCase() === "c") { 
          document.getElementById('highlightBtn').click(); 
          return; 
        }
        if (e.key.toLowerCase() === "k") { 
          document.getElementById('magickeyBtn').click(); 
          return; 
        }
        if (isNoteMode && e.key.toLowerCase() === "a") { 
          isNoteMode = false; 
          updateModeButton();
          updateHighlights();
          return; 
        }
        if (!isNoteMode && e.key.toLowerCase() === "m") { 
          isNoteMode = true; 
          updateModeButton();
          updateHighlights();
          return; 
        }
        if (e.key === "Escape") { 
          document.getElementById('giveUpBtn').click(); 
          return; 
        }
        if (!selectedCell) return;
        const r = parseInt(selectedCell.dataset.row);
        const c = parseInt(selectedCell.dataset.col);
        let newR = r, newC = c;
        switch(e.key) {
          case "ArrowUp": newR = (r > 0) ? r - 1 : r; break;
          case "ArrowDown": newR = (r < 8) ? r + 1 : r; break;
          case "ArrowLeft": newC = (c > 0) ? c - 1 : c; break;
          case "ArrowRight": newC = (c < 8) ? c + 1 : c; break;
          default:
            if (/^[1-9]$/.test(e.key)) {
              onNumberInput(parseInt(e.key));
            }
            return;
        }
        const newCell = document.querySelector(`#npGrid td[data-row="${newR}"][data-col="${newC}"]`);
        if (newCell) {
          if (selectedCell) {
            selectedCell.style.outline = '';
            selectedCell.classList.remove('selected');
          }
          selectedCell = newCell;
          selectedCell.classList.add('selected');
          updateHighlights();
        }
      }
    });
    
    /********************************************
     * 候補ハイライトボタン
    ********************************************/
    document.getElementById('highlightBtn').addEventListener('click', () => {
      const highlightButton = document.getElementById('highlightBtn');
      if (candidateHighlightLevel < 3 && points >= candidateHighlightLevel+1) {
        candidateHighlightLevel++;
        points -= candidateHighlightLevel;
        highlightButton.classList.add('animate-button-plus');
        setTimeout(() => highlightButton.classList.remove('animate-button-plus'), 1000);
        updateCandidateHighlights();
        updateStats();
      }
      else {
        highlightButton.classList.add('animate-button-minus');
        setTimeout(() => highlightButton.classList.remove('animate-button-minus'), 1000);
      }
    });
    
    /********************************************
     * モード切替ボタン（npGridの太枠色更新と選択セル outline 更新）
    ********************************************/
    document.getElementById('modeToggleBtn').addEventListener('click', function(){
      isNoteMode = !isNoteMode;
      updateModeButton();
      updateHighlights();
    });
    function updateModeButton() {
      const btn = document.getElementById('modeToggleBtn');
      if (isNoteMode) {
        btn.innerHTML = "Answer(a)<br>/<b>Memo(m)</b>";
        btn.style.backgroundColor = "var(--color-selected-memo)";
        document.documentElement.style.setProperty('--grid-border-color', "var(--color-selected-memo)");
      } else {
        btn.innerHTML = "<b>Answer(a)</b><br>/Memo(m)";
        btn.style.backgroundColor = "var(--color-difficulty3)";
        document.documentElement.style.setProperty('--grid-border-color', "var(--color-difficulty3)");
      }
      btn.classList.add('animate-button');
      setTimeout(() => btn.classList.remove('animate-button'), 1000);
    }
    
    /********************************************
     * 魔法の鍵ボタン
    ********************************************/
    document.getElementById('magickeyBtn').addEventListener('click', () => {
      const r = parseInt(selectedCell.dataset.row);
      const c = parseInt(selectedCell.dataset.col);
      const magickeyButton = document.getElementById('magickeyBtn');
      if (isNoteMode || board[r][c] !== 0 || points < 50) {
        magickeyButton.classList.add('animate-button-minus');
        setTimeout(() => magickeyButton.classList.remove('animate-button-minus'), 1000);
      }
      else {
        points -= 50;
        onNumberInput(solution[r][c]);
        updateStats();
        magickeyButton.classList.add('animate-button-plus');
        setTimeout(() => magickeyButton.classList.remove('animate-button-plus'), 1000);
      }
    });

    /********************************************
     * 「Give up」ボタン
    ********************************************/
    document.getElementById('giveUpBtn').addEventListener('click', function(){
      clearInterval(timerInterval);
      points--;
      showResult();
    });
    
    /********************************************
     * 「Replay」ボタン（結果画面→スタート画面）
    ********************************************/
    document.getElementById('restartBtn').addEventListener('click', function(){
      const signatureCanvas = document.getElementById('signatureCanvas');
      const sigCtx = signatureCanvas.getContext('2d');
      sigCtx.clearRect(0, 0, signatureCanvas.width, signatureCanvas.height);
      document.getElementById('resultScreen').style.display = "none";
      document.getElementById('gameScreen').style.display = "none";
      document.getElementById('startScreen').style.display = "flex";
      document.getElementById('npGrid').innerHTML = "";
    });

    /********************************************
     * 結果表示（Result Overlay）
    ********************************************/
    function showResult() {
      var dailyBoardOn = document.getElementById('dailyBoardToggle').checked;
      var displayDiff = dailyBoardOn ? diffText + " (DAILY)" : diffText;
      clearInterval(timerInterval);
      const elapsed = Math.floor((new Date() - startTime) / 1000);
      const m = String(Math.floor(elapsed / 60)).padStart(2, '0');
      const s = String(elapsed % 60).padStart(2, '0');
      const score = Math.round(points * 60 / ((Math.floor(elapsed / 60) * 60 + (Math.floor(elapsed % 60)) ) || 1) * (1 - (mistakeCount / (correctCount || 1))));
      var todayStr = new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' });
      document.getElementById('resultDifficulty').innerHTML =
        "<span style='color:" + difficultyColor + "'>" + displayDiff + "</span><br><span style='font-size: var(--font-size-M)'>" + todayStr + "</span>";
      document.getElementById('resultScore').innerHTML = "<span>" + score + "</span>";
      const resultStats = document.getElementById('resultStats');
      resultStats.innerHTML = 
        "<span>" + m + ":" + s + "</span>" +
        "<span>" + points + " pt</span>" +
        "<span>○ " + correctCount + "</span>" +
        "<span>× " + mistakeCount + "</span>" +
        "<span>" + comboCount + " combo</span>";
      document.getElementById('resultScreen').style.display = "flex";
    }
    
    /********************************************
     * Signature Canvas セットアップ（結果画面用）
    ********************************************/
    const signatureCanvas = document.getElementById('signatureCanvas');
    const sigCtx = signatureCanvas.getContext('2d');
    let drawing = false;
    let lastX = 0, lastY = 0;
    
    function drawLine(x, y, isDown) {
      if (!isDown) return;
      sigCtx.beginPath();
      sigCtx.strokeStyle = "#000";
      sigCtx.lineWidth = 1;
      sigCtx.lineCap = "round";
      sigCtx.moveTo(lastX, lastY);
      sigCtx.lineTo(x, y);
      sigCtx.stroke();
      sigCtx.closePath();
      lastX = x;
      lastY = y;
    }
    
    signatureCanvas.addEventListener('mousedown', (e) => {
      drawing = true;
      const rect = signatureCanvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
    });
    signatureCanvas.addEventListener('mousemove', (e) => {
      if (!drawing) return;
      const rect = signatureCanvas.getBoundingClientRect();
      drawLine(e.clientX - rect.left, e.clientY - rect.top, true);
    });
    signatureCanvas.addEventListener('mouseup', () => drawing = false);
    signatureCanvas.addEventListener('mouseout', () => drawing = false);
    // Touch 対応
    signatureCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      drawing = true;
      const rect = signatureCanvas.getBoundingClientRect();
      const touch = e.touches[0];
      lastX = touch.clientX - rect.left;
      lastY = touch.clientY - rect.top;
    });
    signatureCanvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!drawing) return;
      const rect = signatureCanvas.getBoundingClientRect();
      const touch = e.touches[0];
      drawLine(touch.clientX - rect.left, touch.clientY - rect.top, true);
    });
    signatureCanvas.addEventListener('touchend', () => drawing = false);
  </script>
</body>
</html>